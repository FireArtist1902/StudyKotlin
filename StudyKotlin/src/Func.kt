import javax.swing.text.Position

fun main()
{
    //  Функции и их параметры  //
    /*
    Одним из строительных блоков программы являются функции. Функция определяет некоторое действие.
    В Kotlin функция объявляется с помощью ключевого слова fun, после которого идет название
    функции. Затем после названия в скобках указывается список параметров. Если функция возвращает
    какое-либо значение, то после списка параметров через двоеточие можно указать тип возвращаемого
    значения. И далее в фигурных скобках тело функции.

    fun имяФункции(параметры) : возвращаемыйТип{
        тело функции
    }

    Параметры не обязательны. Возвращаемый тип можно не указывать, так как Kotlin обычно сам может его
    вывести на основании тела функции. Например, определим и вызовем функцию, которая просто выводит
    некоторую строку на консоль:
    */

//    hello();

    /*
    Через параметры функция может получать некоторые значения извне. Параметры указываются после имени
    функции в скобках через запятую в формате имяПараметра : типПараметра. Например, определим функцию,
    которая просто выводит сообщение на консоль:
    */

    //showMessage("Hello, World!")

    /*
    Функция showMessage() принимает один параметр типа String. Поэтому при вызове функции в скобках
    необходимо передать значение для этого параметра: showMessage("Hello, World!"). Причем это
    значение должно представлять тип String, то есть строку. Значения, которые передаются параметрам
    функции, еще называют аргументами.

    Другой пример - функция, которая выводит данные о пользователе на консоль:
    */

//    displayUser("Tom", 42);

    /*
    В примере выше при вызове функции showMessage() и displayUser() мы обязательно должны предоставить
    для каждого их параметра какое-то значение, которое соответствует типу параметра. Мы не можем, к примеру,
    вызвать функцию displayUser(), не передав ей аргументы для параметров, это будет ошибка.

    Однако мы можем определить некоторые параметры функции как необязательные и установить для них
    значения по умолчанию.
    */

//    displayUser("Tom", 23, "Manager");
//    displayUser("Alice", 21)
//    displayUser("Kate");

    /*
    В данном случае функция displayUser() имеет три параметра для передачи имени, возраста и должности.
    Для первого параметра name значение по умолчанию не установлено, поэтому для него значение по-прежнему
    обязательно. Два последующих - являются не обязательными, и для них установлены значения по умолчанию.
    Если для этих параметров не передаются значения, тогда параметры используют значения пол умолчанию.
    Поэтому для этих параметров в принципе нам не обязательно передавать аргументы. Но если для какого-то
    параметра определено значение по умолчанию, то для всех последующих параметров тоже должно быть
    установлено значение по умолчанию.

    По умолчанию значения передаются параметрам по позиции: первое значение - первому параметру, второе
    значение - второму параметру и так далее. Однако, используя именованные аргументы, мы можем переопределить
    порядок передачи параметров:
    */

//    displayUser("Tom", position = "Manager", age = 28);
//    displayUser(age = 21, name = "Alice");
//    displayUser("Kate", position = "Middle Developer");

    /*
    При вызове функции в скобках мы можем указать название параметра и с помощью знака равно передать
    ему нужное значение.

    При этом, как видно из последнего случая, необязательно все аргументы передавать по имени. Часть
    аргументов могут передаваться параметрам по позиции. Но если какой-то аргумент передан по имени, то
    остальные аргументы после него также должны передаваться по имени соответствующих параметров.

    Также если до обязательного параметра функции идут необязательные параметры, то для обязательного
    параметра значение передается по имени.
    */

    //  Переменное количество параметров    //

    /*
    Функция может принимать переменное количество параметров одного типа. Для определения таких параметров
    применяется ключевое слово vararg. Например, нам необходимо передать в функцию несколько строк,
    но сколько именно строк, мы точно не знаем. Их может быть пять, шесть, сем и тд.
    */

    //printStrings("Tom", "Bob", "Sam");

    /*
    Функция printStrings() принимает неопределенное количество строк. В самой функции мы можем
    работать с параметром как с последовательностью строк, например, перебирать элементы
    последовательности в цикле и производить с ними некоторые действия. При вызове функции
    мы можем ей передать любое количество строк.

    Другой пример - подсчет суммы неопределенного количества чисел:
    */

    //sum(1, 2, 3, 4, 5, 6, 7, 8, 9);

    /*
    Если функция принимает несколько параметров, то обычно vararg-параметр стоит последним

    Однако не обязательно, по если после vararg идет еще какие-нибудь параметры, то при вызове функции
    значения этим параметрам передается через именованные аргументы
    */

    //  Возвращение результата  //

    /*
    Функция может возвращать некоторый результат. В этом случае после списка параметров через
    двоеточие указывается возвращаемый тип. А в теле функции применяется оператор return,
    после которого указывается возвращаемое значение.

    Например, определим функцию, которая возвращает сумму двух чисел:
    */

//    val a = sum(4, 3)
//    val b = sum(5, 6)
//    val c = sum(6, 9);
//    println("a = $a, b = $b, c = $c")

    /*
    Если функция не возвращает какого-либо результата, то фактически неявно она возвращает значение
    типа Unit. Этот тип аналогичен типу void в ряде языков программирования, который указывает,
    что функция ничего не возвращает.
    */

    //  Однострочные и локальные функции    //

    /*
    Однострочные функции используют сокращенный синтаксис определения функции в виде одного выражения.
    Эта форма позволяет упустить возвращаемый тип и оператор return:

    fun имяФункции (параметры) = телоФункции

    Функция также определяется с помощью ключевого слова fun, после которого идет имя функции и список
    параметров. Но после списка параметров не указывается возвращаемый тип. Возвращаемый тип быдет
    выводиться компилятором. Далее через оператор присвоения = определяется тело функции в виде
    одного выражения.

    Например, функция возведения числа в квадрат:
    */

//    val a = square(5);
//    val b = square(6);
//    println("a = $a, b = $b");

    /*
    В данном случае функция возводит число в квадрат. Она состоит из одного выражения х * х.
    Значение этого выражения будет возвращаться функцией. При этом оператор return не нужен.
    */

    //  Перегрузка функций  //

    /*
    Перегрузка функции представляет определение нескольких функций с одним и тем же именем,
    но с различными параметрами. Параметры перегруженных функций могут отличаться по
    количеству, типу или по порядку в списке параметров.
    */

    //  Тип функции //

    /*
        В Kotlin все является объектом, в том числе и функции. И функции, как и другие
        объекты имеют определенный тип. Тип функции определяется следующим образом:
        (типыПараметров) -> возвращаемыйТип.

        Возьмем в пример функцию hello(), которая не принимает параметров и ничего
        не возвращает.

        Она имеет тип () -> Unit

        Если функция не принимает параметров, в определении типа указываются пустые
        скобки. Если не указан возвращаемый тип, то фактически в качестве типа
        возвращаемого значения применяется тип Unit.

        Возьмем функцию sum(a: Int, b: Int);

        Эта функция принимает два параметра типа Int и возвращает значение типа Int,
        поэтому она имеет тип:
         (Int, Int) -> Int

         Для чего нам знание типа функции? Используя тип функции, мы можем определять
         переменные и параметры других функций, которые будут представлять функции.


         Переменная может представлять функцию. С помощью типа функции можно определить,
         какие именно функции переменная может представлять:
    */

//    val message : () -> Unit;
//    message = ::hello;
//    message();

    /*
    Здесь переменная message представляет функцию с типом () -> Unit, то есть функцию
    без параметров, которая ничего не возвращает. Далее определена как раз такая
    функция - hello(), соответственно мы можем передать функцию hello переменной.

    Чтобы передать функцию, перед названием функции ставится оператор ::

    Затем мы можем обращаться к переменной message() как к обычной функции.

    Рассмотрим другой пример, когда переменная ссылается на функцию с параметрами:
    */

//    val operator: (Int, Int) -> Int = ::sum;
//    val result = operator(3, 5);
//    println(result);

    /*
    Переменная operator представляет функцию с типом (Int, Int) -> Int, то есть
    функцию с двумя параметрами типа Int и возвращаемым значением типа Int.
    Соответственно такой переменной можем присвоить функцию sum, которая
    соответствует этому типу.

    При этом динамически можно менять значение, главное чтобы оно соответствовало
    типу переменной:
    */

//    var operation: (Int, Int) -> Int = ::sum;
//    val result1 = operation(14, 5);
//    println(result1);
//
//    operation = ::subtract;
//    val result2 = operation(14, 5);
//    println(result2);

    //  Функции высокого порядка    //
    /*
     Функции высокого порядка - это функции, которые либо принимают функцию в качестве параметра,
     либо возвращают функцию, либо и то, и другое.

     Чтобы функция могла принимать другую функцию через параметр, этот параметр должен представлять
     тип функции:
    */

//    displayMessage(::morning);
//    displayMessage(::evening);
//    displayMessage { println("Hello, World!") }

    /*
    В данном случае функция displayMessage() через параметр mes() принимает функцию типа () -> Unit,
    то есть функцию, которая не имеет параметров и ничего не возвращает. При вызове функции мы можем
    пережать этому параметру функцию, которая соответствует этому типу.

    Рассмотрим пример параметра-функции, которая принимает параметры:
    */

//    action(5, 3, ::sum);
//    action(5, 3, ::multiply);
//    action(5, 3, ::subtract);

    /*
    Здесь функция action принимает три параметра. Первые два - значения типа Int. А третий параметр
    представляет функцию, которая имеет тип (Int, Int) -> Int, то есть принимает два числа и
    возвращает некоторое число.

    В самой функции action вызываем это параметр-функцию, передавая ей два числа, и полученный
    результат выводим на консоль.

    При вызове функции action мы можем передать для ее третьего параметра конкретную функцию,
    которая соответствует этому параметру по типу.

    В более редких случаях может потребоваться возвратить функцию из другой функции.
    В этом случае для функции в качестве возвращаемого типа устанавливается тип другой
    функции. А в теле функции возвращается лямбда выражение. Например:
    */
//    val action1 = selectAction(1);
//    println(action1(8, 5));
//    val action2 = selectAction(2);
//    println(action2(8, 5));

    //  Анонимные функции   //

    /*
    Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени.
    Анонимная функция может иметь одно выражение:
    */

//    fun(x: Int, y: Int): Int = x + y;
    /*
    Либо можем представлять блок кода:
    */

//    fun(x: Int, y: Int): Int
//    {
//        return x + y;
//    }

    /*
    Анонимную функцию можно передавать в качестве значения переменной
    */

//    val message = fun() = println("Hello, World!");
//    message();

    /*
    Другой пример - анонимная функция с параметрами:
    */

//    val sum = fun(x: Int, y: Int): Int = x + y;
//    val result = sum(4, 5);
//    println(result);

    //  Лямбда-выражения    //

    /*
    Лямбда-выражения представляют собой небольшие кусочки кода, которые выполняют
    некоторые действия. Фактически лямбды представляют сокращенную запись функции.
    При этом лямбды, как и обычные и анонимные функции, могут передаваться в качестве
    значения переменным и параметрам функции.

    Лямбда-выражения оборачиваются в фигурные скобки:
    */

//    val hello = {println("Helo, World!")}
//    hello();

    /*
    В данном случае лямбда сохранена в переменную hello() и вызывается через нее.
    Поскольку лямбда-выражение представляет сокращенную форму функции, то переменная
    hello имеет тип () -> Unit.

    Также лямбда-выражение можно запускать как обычную функцию, используя круглые скобки:
    */

//    {println("Hello, World!")}();

    /*
    Лямбды, как и функции могут принимать параметры. Для передачи параметров используется
    стрелка ->. Параметры указываются слева от стрелки, а тело, то есть выполняемые действия,
    справа от стрелки.
    */

//    val printer = {message: String -> println(message)};
//    printer("Hello, World!");

    /*
    Здесь лямбда-выражение принимает один параметр типа String, значение которого выводится на консоль.
    Переменная printer в данном случае имеет тип (String) -> Unit.

    Если параметров несколько, то они передаются слева от стрелки через запятую:
    */

//    val sum = {x: Int, y: Int -> println(x + y)};
//    sum(2, 3);
//    sum(4, 5);

    /*
    Выражение, стоящее после стрелки, определяет результат лямбда-выражения. И этот результат мы можем
    присвоить, например, переменной.
    */

//    val sum = {x: Int, y: Int -> x + y};
//    val a = sum(2, 3);
//    val b = sum(4, 5);
//    println("a = $a, b = $b");

    /*
    Если лямбда-выражение многострочное, состоит из нескольких инструкция, то возвращается значение,
     которое генерируется последней инструкцией:
    */

//    val sum = {x: Int, y: Int ->
//        val result = x + y;
//        println(result);
//        result
//    }
}

fun selectAction(key: Int): (Int, Int) -> Int
{
    return when(key)
    {
        1-> ::sum;
        2-> ::subtract;
        3-> :: multiply
        else -> ::empty;
    }
}

fun action(n1: Int, n2: Int, op: (Int, Int) -> Int)
{
    val result = op(n1, n2);
    println(result);
}

fun displayMessage(mes: () -> Unit)
{
    mes();
}

fun morning()
{
    println("Good Morning");
}

fun evening()
{
    println("Good Evening");
}

fun square(x : Int) = x * x;

fun empty(a: Int, b: Int): Int
{
    return 0;
}

fun multiply(a: Int, b: Int) : Int
{
    return a * b;
}

fun subtract(x: Int, y: Int) : Int
{
    return  x - y;
};

fun sum(x : Int, y : Int) : Int
{
    return x + y;
}

fun sum(vararg numbers : Int)
{
    var result = 0;
    for(n in numbers)
    {
        result += n
    }

    println("Сумма чисел равна: $result")
}

fun printStrings(vararg strings : String)
{
    for(str in strings)
    {
        println(str);
    }
}

fun displayUser(name: String, age: Int = 0, position: String = "unemployed")
{
    println("Name: $name, Age: $age, Position: $position");
}

fun showMessage(message: String)
{
    println(message);
}

fun hello(){
    println("Hello")
}