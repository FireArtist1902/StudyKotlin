const val maxAge = 120;

fun main() {
    //  Переменные   //
    // val|var var_name : var_type

//    var age : Int;
//    age = 23;
//    println(age);

    /*
    Присвоение значения переменной должно производиться только после ее
    объявления. И также мы можем сразу присвоить переменной начальное
    значение при ее объявлении. Такой прием называется инициализацией:
    */

//    var age: Int = 23;
//    println(age);

    /*
    С помощью ключевого слова "val" определяется неизменяемая переменная или
    переменная только для чтения (read-only). То есть мы можем присвоить
    значение такой переменной только один раз, но изменить его после первого
    присвоения мы уже не сможем.
    */

    //val age: Int;
    //age = 23 //Норм, первое присвоение
    //age = 32 Ошибка - пере присвоение
    //println(age);

    /*
    А у переменной, которая определена с помощью ключевого слова "var"
    мы можем многократно менять значение
    */

//    var age: Int;
//    age = 23;
//    println(age);
//    age = 32;
//    println(age);

    /*
    Также Kotlin поддерживает константы времени компиляции. Для их
    определения применяются ключевые слова "const val". Константа
    должна определяться на самом верхнем уровне (вне класса/функции)
    */
    //println(maxAge);

    //maxAge = 156 Ошибка

    //  ТИПЫ ДАНЫХ  //
    /*
    Целочисленные типы:
    Byte - хранит целое число от -128 до 127 и занимает 1 байт,
    Short - хранит целое число от -23768 до 32767 и занимает 2 байта,
    Int - хранит целое число от -2147483648 до 2147483647 и занимает 4 байта,
    Long - хранит целое число от -92333327036854775808 до
    92333327036854775807 и занимает 8 байт,

    В последней версии Kotlin также добавлена поддержка для целочисленных
    типов без знака:

    UByte - хранит целое число от 0 до 255 и занимает 1 байт,
    UShort - хранит целое число от 0 до 65535 и занимает 2 байта,
    UInt - хранит целое число от 0 до 2^32 - 1 и занимает 4 байта,
    ULong - хранит целое число от 0 до 2^64 - 1 и занимает 8 байт
    */

//    val a : Byte = -10;
//    val b : Short = 45;
//    val c : Int = -250;
//    val d : Long = 30000;
//    println(a);// -10
//    println(b);// 45
//    println(c);// -250
//    println(d);// 30000

    /*
    Кроме целочисленных типов в Kotlin есть 2 типа чисел с плавающей
    точкой, которые позволяют хранить дробные числа

    Float - хранит число с плавающей точкой от -3,4*10^38 до 3,4*10^38
    и занимает 4 байта,
    Double - хранит число с плавающей точкой от +-5,0*10^324 до +-1,7*10^308
    и занимает 8 байт
    */

//    val height : Double = 1.78;
//    val pi : Float = 3.14F;
//    println(height);
//    println(pi);
    // Вывод информации в консоль //
    /*
    Для вывода информации на консоль в Kotlin есть две встроенные функции
    print(), println()
    Обе эти функции принимают некоторый объект, который надо вывести на консоль,
    обычно это строка. Различие между ними состоит в том, что функция println()
    при выводе добавляет перевод на новую строку
    */

//    print("Hello")
//    print("Kotlin")
//    print("on Metanit.com")
//    println()
//    println("Kotlin is a fun")

    /*
    Причем функция println() необязательно должна принимать некоторые значения.
    Так, здесь, применяется пустой вызов функции который просто переводит консольный вывод на новую строку
    */

    //Ввод с консоли //

    /*
    Для ввода с консоли применяется встроенная функция readLine(). Она возвращает введенную строку. Стоит
    отметить, что результат этой функции всегда представляет объект типа String. Соответственно
    введенную строку мы можем передать в переменную типа String
    */

//    print("Введите имя: ")
//    val name = readLine();
//    println("Ваше имя: $name");

    // Условные конструкции //

    /*
    Условные конструкции позволяют направить выполнение программы по одному из путей в зависимости
    от условий. Конструкция if принимает условие, и если оно истинно, то выполняется последующий блок инструкций
    */

//    val a = 10;
//    if(a == 10)
//    {
//        println("a = 10");
//    }

    /*
    В данном случае в конструкции if проверяется истинность выражения а = 10, если оно истинно, то выполняется
    последующий блок кода в фигурных скобках, и на консоль выводиться сообщение "а = 10". Если выражение ложно,
    тогда блок кода не выполняется. Если необходимо задать альтернативный вариант, то можно добавить
    блок else:
    */

//    val a = 10;
//    if(a == 10)
//    {
//        println("a = 10");
//    } else
//    {
//        println("a != 10");
//    }

    /*
    Стоит отметить, что конструкция if может возвращать значение. Например, найдем максимальное их двух чисел:
    */

//    val a = 10;
//    val b = 20;
//    val c = if (a > b) a else b

    /*
    Если при определении возвращаемого значения надо выполнить еще какие-нибудь действия, то можно заключить
    эти действия в блоки кода:
    */

//    val a = 10;
//    val b = 20;
//    val c = if(a > b)
//    {
//        println("a = $a")
//        a
//    }else{
//        println("b = $b")
//        b
//    }

    /*
    В конце каждого блока указывается возвращаемое значение
    */

    //  Конструкция when  //

    /*
    Конструкция when проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или
    иной код. Конструкция when аналогична конструкции switch в других языках. Формальное определение:
    when(объект)
    {
        значение1 -> действия1
        значение2 -> действия2

        значениеN -> действияN
    }

    Если значение объекта равно одному из значений в блоке when, то выполняются соответствующие действия,
    которые идут после оператора -> после соответствующего значения. Например:
    */

//    val isEnabled = true;
//    when(isEnabled)
//    {
//        false -> println("isEnabled off")
//        true -> println("isEnabled on")
//    }

    /*
    В примере выше переменная isEnabled имела только два возможных варианта: true и false. Однако чаще
    бывают случаи, когда значения в блоке when не покрывают все возможные значения объекта. Дополнительное
    выражение else позволяет задать действия, которые выполняются, если объект не соответствует ни одному
    из значений. Например:
    */

//    val a = 30;
//    when(a)
//    {
//        10 -> println("a = 10")
//        20 -> println("a = 20")
//        else -> println("неопределенное значение")
//    }

    /*
    То есть в данном случае если переменная "а" равна 30, поэтому не соответствует ни одному из значений в блоке
    when. И соответственно будут выполнятся инструкции из выражения else.
    Если надо, чтобы при совпадении значений выполнялось несколько инструкций, то для каждого значения можно
    определить блок кода:
    */

//    var a = 10;
//    when(a)
//    {
//        10 ->{
//            println("a = 10")
//            a *= 2
//        }
//        20 ->{
//            println("a = 10")
//            a *= 5
//        }
//        else -> println("Неопределенное значение")
//    }
//    println(a);

    /*
    Можно определить одни и те же действия сразу для нескольких значений. В этом случае значения
    перечислятся через запятую:
    */

//    val a = 10;
//    when(a)
//    {
//        10, 20 -> println("a = 10 или a = 20")
//        else -> println("Неопределенное значение")
//    }

    /*
    Также можно сравнивать с целым диапазоном значений с помощью оператора in:
    */

//    val a = 10;
//    when(a)
//    {
//        in 10..19 -> println("а в диапазоне от 10 до 19")
//        in 20..29 -> println("а в диапазоне от 20 до 29")
//        !in 10..20 -> println("а вне диапазона от 10 до 20")
//        else -> println("Неопределенное значение")
//    }

    /*
    Если оператор in позволяет узнать, есть ли значение в определенном диапазоне, то связка операторов
    !in позволяет проверить отсутствие значения в определенной последовательности.

    Выражение when также может сравниваться с динамически вычисляемыми значениями:
    */

//    val a = 10;
//    val b = 5;
//    val c = 3;
//    when(a)
//    {
//        b - c -> println("a = b - c")
//        b + 5 -> println("a = b + 5")
//        else -> println("Неопределенное значение")
//    }

    /*
    Так, в данном случае значение переменой "a" сравнивается с результатами операций b - c и b + 5

    Кроме того, when также может принимать динамически вычисляемый объект
    */

//    val a = 10;
//    val b = 20
//    when(a + b)
//    {
//        10 -> println("a + b = 10")
//        20 -> println("a + b = 20")
//        30 -> println("a + b = 30")
//        else -> println("Undefined")
//    }

    /*
    Можно даже определять переменные, которые будут доступны внутри блока when:
    */

//    val a = 10;
//    val b = 26;
//    when(val c = a + b)
//    {
//        10 -> println("a + b = 10")
//        20 -> println("a + b = 20")
//        else -> println("c = $c")
//    }

    /*
    Причем нам не обязательно вообще сравнивать значение какого-либо объекта. Конструкция
    when аналогично конструкции if..else просто может проверять набор условий и если
    одно из условий возвращает true, то выполняет соответствующий набор действий:
    */

//    val a = 15;
//    val b = 6;
//    when
//    {
//        (b > 10) -> println("b больше 10")
//        (a > 10) -> println("a больше 10")
//        else -> println("и a, и b меньше или равны 10")
//    }

    /*
    Как и if конструкция when может возвращать значение. Возвращаемое значение указывается
    после оператора ->:
    */

//    val day = 2
//    var dayOfWeek = when(day) {
//        1 -> "Monday"
//        2 -> "Tuesday"
//        3 -> "Wednesday"
//        4 -> "Thursday"
//        else -> "Unknown"
//    }
//    println(dayOfWeek)

    /*
    Другой пример:
    */

//    val sum = 1000
//    val rate = when(sum){
//        in 100..999 -> 10
//        in 1000..9999 -> 15
//        else -> 20
//    }
//    println(rate)

    // Циклы //

    /*
    Циклы представляют вид управляющих конструкций, которые позволяют в зависимости от
    определенных условий выполнять некоторое действие много раз.

    Цикл for пробегается по всем элементам коллекции. В этом плане for в Kotlin
    эквивалентен циклу for-each в ряде других языков программирования. Его
    формальная форма выглядит следующим образом:

    for(переменная in последовательность)
    {
        выполняемые инструкции
    }

    Например, выведем все квадраты чисел от 1 до 9, используя цикл for
    */

//    for(n in 1..9)
//    {
//        print("${n * n} \t");
//    }

    /*
    В данном случае передирается последовательность чисел от 1 до 9. При каждом проходе (итерации) цикла
    из этой последовательности будет извлекаться элемент и помещаться в переменную n. И через
    переменную можно манипулировать значением элемента.

    Циклы могут быть вложенными. Например, выведем таблицу умножения:
    */

//    for(i in 1..9)
//    {
//        for(j in 1..9)
//        {
//            print("${i * j} \t")
//        }
//        println()
//    }

    /*
    Цикл while повторяет определенные действия пока истинно некоторое условие
    */

//    var i = 10;
//    while (i > 0)
//    {
//        println(i*i)
//        i--
//    }

    /*
    Здесь пока переменная і больше 0, будет выполнятся цикл, в котором на консоль будет выводиться
    квадрат значения i

    Есть и другая форма цикла while - do..while
    */

//    var i = -1;
//    do{
//        println(i * i)
//        i--;
//    }while (i > 0)

    /*
    В данном случае вначале выполняется блок кода после ключевого слова do, а потом оценивается
    условие после while. Если условие истинно, то повторяется выполнение блока после do.
    То есть несмотря на тоЮ что в данном случае переменная меньше 0 и она не соответствует
    условию, тем не менее блок do выполнится хотя бы один раз

    Иногда при использовании цикла возникает необходимость при некоторых условиях не
    дожидаться выполнения всех инструкций в цикле, перейти к новой итерации. Для этого
    можно использовать оператор continue
    */

//    for(n in 1..8)
//    {
//        if(n == 5) continue;
//        println(n * n);
//    }

    /*
    В данном случае когда n окажется равен 5, то сработает оператор continue. И последующая инструкция,
    которая выводит на консоль квадрат числа, не будет выполнятся. Цикл перейдет к обработке
    следующего элемента в массиве.

    Бывает, что при некоторых условиях нам вовсе надо выйти из цикла, прекратить его выполнение.
    В таком случае применяется оператор break.
    */

//    for (n in 1..5)
//    {
//        if(n == 5) break;
//        println(n * n)
//    }

    /*
    В данном случае когда n окажется равен 5, то с помощью оператора break будет выполнен выход из цикла.
    Цикл полностью завершится. Однако следует помнить, что оператор break выводит только из текущего
    цикла, где он вызывается. Например, возьмем следующую конструкцию:
    */

//    for(i in 1..3)
//    {
//        for(j in 1..3)
//        {
//            if(j == 3) break;
//            println("Hello");
//        }
//    }

    /*
    Каждый раз во внутреннем цикле j окажется равна 3, произойдет переход к новой итерации цикла по i.
    Но сто если нам надо вообще выйти из всех циклов, в том числе из внешнего? Наиболее простым в данном
    случае способом будет использование меток:
    */

//    outerloop@ for(i in 1..3)
//    {
//        for(j in 1..3)
//        {
//            if(j == 3) break@outerloop;
//            println("Hello");
//        }
//    }

    /*
    В даном случае внешний цикл маркирован меткой outerloop. Название метки произвольное, единственное,
    что завершается символом @. И когда во внутреннем цикле будет выполнятся условие j == 3 оператор
    break выйдет из цикла, предваряемого меткой outerloop
    */

}